
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

# Helper functions

def lookup(cur: dict, struct: dict, attrs: list) -> int: 
    """
    Search for a given "group by" attribute value(s) in mf_struct. 
    If the value(s) doesn't exist then return -1, else return the index for that row.

    :param cur: Current row in the mf_struct.
    :param struct: The mf_struct.
    :param attrs: List of the grouping attributes that make up the key in the mf_struct.
    :return: Either the index of the matching row in mf_struct or -1 if not found.
    """

    key = () # compute key using row's grouping attribute values
    for attr in attrs:
        key += (cur[attr],)
    if key in struct.keys():
        return True
    return False



def add(cur: dict, struct: dict, attrs: list, aggs: list):
    """
    Adds new row to mf_struct.

    :param cur: Current row from base table.
    :param struct: The mf_struct the new row goes to.
    :param attrs: List of attributes whose values from cur will get added to the new row
    :param aggs: List of aggregates for each grouping variable
    """
    key = () # compute key using row's grouping attribute values
    for attr in attrs:
        key += (cur[attr],)
    value = dict()
    for agg in aggs:
        value[agg] = 0
    struct[key] = value



def output(struct: dict, attrs: list):
    """
    Print the rows of a given mf_struct.
    mf_struct's keys are the grouping attribute values themselves. Thus, we convert the keys into a dictionary where the key is the attribute's name (in attrs) and the value is the attribute's value (i.e. mf_struct key). Since the mf_struct's values are dictionaries that store the aggregates, we can combine the two dictionaries to produce a row of the mf_struct consisting of the grouping attributes and the aggregates.

    Example:

    For each mf_struct key-value pair -> 
    ("Sam") : {
         "1_sum_quant" : 10,
         "2_avg_quant" : 20,
    }

    Convert into a dictionary ->
    {"cust": "Sam", "1_sum_quant" : 10, "2_avg_quant" : 20}

    :param struct: The mf_struct we want to print.
    :param attrs: List of grouping attributes names.
    """
    
    ret = [] # stores rows of mf_struct
    # iterate through each entry of mf_struct
    for keys in struct.keys():
        d = {} # initialize a new dictionary that'll stores the row corresponding to the current entry 
        # a key is a tuple so we iterate through each key and map them with their corresponding attribute name
        for key, attr in zip(keys, attrs):
            d[attr] = key
        d.update(struct.get(keys)) # combine the entry's dictionary with the dictionary associated to that entry's value
        ret.append(d) # add it to the list of rows  
    print(tabulate.tabulate(ret, headers="keys", tablefmt="psql")) # print the final table
    

def update(row: dict, struct: dict, attrs: list, aggs: list, cond: str):
    """
    Updates the rows in mf_struct that are related to the given row.

    :param row: Current row from the base table.
    :param struct: The mf_struct that we're updating.
    :param attrs: Grouping attributes that define the keys of mf_struct
    :param aggs: Aggregates that are being computed for the grouping variable
    :param cond: Condition that define the grouping variable's range
    """
    # print(f"Pred: {preds}, Aggs: {aggs}, Attrs: {attrs}")
    
    # construct key that defines a grouping variable's range
    key = ()
    for attr in attrs:
        key += (row[attr],)
    row["state"]="NY"
    row["quant"] = 100
    print(f"Condition: {cond}")
    if eval(cond):
        print("Success!")
        for agg in aggs:
            (var, op, att) = agg.split("_")
            match op:
                case 'sum':
                    struct[key][agg] += row[att]
                case 'count':
                    struct[key][agg] += 1
                case 'max':
                    struct[key][agg] = max(struct[key], row[att])
                case 'min':
                    struct[key][agg] = min(struct[key], row[att])
                case 'avg':
                    struct[key][agg] = 0
        exit()
    else:
        print("Failure")
        exit()
        

    # iterate through mf_struct to identify rows that satisfy grouping variable's range w.r.t the given row
    # entry = struct.get(key)
    
    
def query():
    load_dotenv() # reads the .env file

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales") # prints all the rows in the data table
    
    _global = []
    mf_struct = {}
    
    table = cur.fetchall() # store the SQL query output into a list so that it can be scanned multiple times
    for i in range(4):
        for row in table:
            # scan 0 adds rows with distinct grouping attributes 
            if i == 0:
                exists = lookup(row, mf_struct, ['cust', 'prod'])
                if not exists:
                    add(row, mf_struct, ['cust', 'prod'], ['0_sum_quant', '1_sum_quant', '1_avg_quant', '2_sum_quant', '3_sum_quant', '3_avg_quant'])
                update(row, mf_struct, ['cust', 'prod'], [['0_sum_quant'], ['1_sum_quant', '1_avg_quant'], ['2_sum_quant'], ['3_sum_quant', '3_avg_quant']][i], "True") # update the rows in mf_struct corresponding to i=0 (aggregates over the standard SQL groups)
            else:
                update(row, mf_struct, ['cust', 'prod'], [['0_sum_quant'], ['1_sum_quant', '1_avg_quant'], ['2_sum_quant'], ['3_sum_quant', '3_avg_quant']][i], ["row['state']=='NY' and row['quant']<=100 ", "row['state']=='NJ'", "row['state']=='CT'"][i-1]) # update the rows in mf_struct corresponding to i!=0 (aggregates over the grouping variables)             

    output(mf_struct, ['cust', 'prod'])
    print(f"Entries: {len(mf_struct.keys())}")

    

    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql") # returns data as a table

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    